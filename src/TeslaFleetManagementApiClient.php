<?php

declare(strict_types=1);

/*
 * TeslaFleetManagementApiLib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

namespace TeslaFleetManagementApiLib;

use Core\ClientBuilder;
use Core\Utils\CoreHelper;
use TeslaFleetManagementApiLib\Authentication\BearerAuthCredentials;
use TeslaFleetManagementApiLib\Authentication\BearerAuthCredentialsBuilder;
use TeslaFleetManagementApiLib\Authentication\BearerAuthManager;
use TeslaFleetManagementApiLib\Authentication\ThirdpartytokenCredentials;
use TeslaFleetManagementApiLib\Authentication\ThirdpartytokenCredentialsBuilder;
use TeslaFleetManagementApiLib\Authentication\ThirdpartytokenManager;
use TeslaFleetManagementApiLib\Controllers\ChargingController;
use TeslaFleetManagementApiLib\Controllers\EnergyController;
use TeslaFleetManagementApiLib\Controllers\OAuthAuthorizationController;
use TeslaFleetManagementApiLib\Controllers\PartnerController;
use TeslaFleetManagementApiLib\Controllers\UserController;
use TeslaFleetManagementApiLib\Controllers\VehicleCommandsController;
use TeslaFleetManagementApiLib\Controllers\VehiclesController;
use TeslaFleetManagementApiLib\Logging\LoggingConfigurationBuilder;
use TeslaFleetManagementApiLib\Logging\RequestLoggingConfigurationBuilder;
use TeslaFleetManagementApiLib\Logging\ResponseLoggingConfigurationBuilder;
use TeslaFleetManagementApiLib\Proxy\ProxyConfigurationBuilder;
use TeslaFleetManagementApiLib\Utils\CompatibilityConverter;
use Unirest\Configuration;
use Unirest\HttpClient;

class TeslaFleetManagementApiClient implements ConfigurationInterface
{
    private $charging;

    private $energy;

    private $partner;

    private $user;

    private $vehicles;

    private $vehicleCommands;

    private $oAuthAuthorization;

    private $bearerAuthManager;

    private $thirdpartytokenManager;

    private $loggingConfigurationBuilder;

    private $proxyConfiguration;

    private $config;

    private $client;

    /**
     * @see TeslaFleetManagementApiClientBuilder::init()
     * @see TeslaFleetManagementApiClientBuilder::build()
     *
     * @param array $config
     */
    public function __construct(array $config = [])
    {
        $this->config = array_merge(ConfigurationDefaults::_ALL, CoreHelper::clone($config));
        $this->bearerAuthManager = new BearerAuthManager($this->config);
        $this->thirdpartytokenManager = new ThirdpartytokenManager($this->config);
        $this->validateConfig();
        $loggingConfiguration = null;
        if ($this->config['loggingConfiguration'] instanceof LoggingConfigurationBuilder) {
            $this->loggingConfigurationBuilder = $this->config['loggingConfiguration'];
            $loggingConfiguration = $this->loggingConfigurationBuilder->build();
        }
        $this->proxyConfiguration = $this->config['proxyConfiguration'] ?? ConfigurationDefaults::PROXY_CONFIGURATION;
        $this->client = ClientBuilder::init(
            new HttpClient(Configuration::init($this)->proxyConfiguration($this->proxyConfiguration))
        )
            ->converter(new CompatibilityConverter())
            ->jsonHelper(ApiHelper::getJsonHelper())
            ->apiCallback($this->config['httpCallback'] ?? null)
            ->userAgent('PHP SDK, Version: 1.0.4, on OS {os-info}')
            ->serverUrls(self::ENVIRONMENT_MAP[$this->getEnvironment()], Server::DEFAULT_)
            ->authManagers(
                ['bearerAuth' => $this->bearerAuthManager, 'thirdpartytoken' => $this->thirdpartytokenManager]
            )
            ->loggingConfiguration($loggingConfiguration)
            ->build();
        $this->thirdpartytokenManager->setClient($this->client);
    }

    /**
     * Create a builder with the current client's configurations.
     *
     * @return TeslaFleetManagementApiClientBuilder TeslaFleetManagementApiClientBuilder instance
     */
    public function toBuilder(): TeslaFleetManagementApiClientBuilder
    {
        $builder = TeslaFleetManagementApiClientBuilder::init()
            ->timeout($this->getTimeout())
            ->enableRetries($this->shouldEnableRetries())
            ->numberOfRetries($this->getNumberOfRetries())
            ->retryInterval($this->getRetryInterval())
            ->backOffFactor($this->getBackOffFactor())
            ->maximumRetryWaitTime($this->getMaximumRetryWaitTime())
            ->retryOnTimeout($this->shouldRetryOnTimeout())
            ->httpStatusCodesToRetry($this->getHttpStatusCodesToRetry())
            ->httpMethodsToRetry($this->getHttpMethodsToRetry())
            ->environment($this->getEnvironment())
            ->httpCallback($this->config['httpCallback'] ?? null)
            ->proxyConfiguration($this->getProxyConfigurationBuilder());

        $bearerAuth = $this->getBearerAuthCredentialsBuilder();
        if ($bearerAuth != null) {
            $builder->bearerAuthCredentials($bearerAuth);
        }

        $thirdpartytoken = $this->getThirdpartytokenCredentialsBuilder();
        if ($thirdpartytoken != null) {
            $builder->thirdpartytokenCredentials($thirdpartytoken);
        }
        $loggingConfigurationBuilder = $this->getLoggingConfigurationBuilder();
        if ($loggingConfigurationBuilder != null) {
            $builder->loggingConfiguration($loggingConfigurationBuilder);
        }
        return $builder;
    }

    public function getTimeout(): int
    {
        return $this->config['timeout'] ?? ConfigurationDefaults::TIMEOUT;
    }

    public function shouldEnableRetries(): bool
    {
        return $this->config['enableRetries'] ?? ConfigurationDefaults::ENABLE_RETRIES;
    }

    public function getNumberOfRetries(): int
    {
        return $this->config['numberOfRetries'] ?? ConfigurationDefaults::NUMBER_OF_RETRIES;
    }

    public function getRetryInterval(): float
    {
        return $this->config['retryInterval'] ?? ConfigurationDefaults::RETRY_INTERVAL;
    }

    public function getBackOffFactor(): float
    {
        return $this->config['backOffFactor'] ?? ConfigurationDefaults::BACK_OFF_FACTOR;
    }

    public function getMaximumRetryWaitTime(): int
    {
        return $this->config['maximumRetryWaitTime'] ?? ConfigurationDefaults::MAXIMUM_RETRY_WAIT_TIME;
    }

    public function shouldRetryOnTimeout(): bool
    {
        return $this->config['retryOnTimeout'] ?? ConfigurationDefaults::RETRY_ON_TIMEOUT;
    }

    public function getHttpStatusCodesToRetry(): array
    {
        return $this->config['httpStatusCodesToRetry'] ?? ConfigurationDefaults::HTTP_STATUS_CODES_TO_RETRY;
    }

    public function getHttpMethodsToRetry(): array
    {
        return $this->config['httpMethodsToRetry'] ?? ConfigurationDefaults::HTTP_METHODS_TO_RETRY;
    }

    public function getEnvironment(): string
    {
        return $this->config['environment'] ?? ConfigurationDefaults::ENVIRONMENT;
    }

    public function getBearerAuthCredentials(): BearerAuthCredentials
    {
        return $this->bearerAuthManager;
    }

    public function getBearerAuthCredentialsBuilder(): ?BearerAuthCredentialsBuilder
    {
        if (empty($this->bearerAuthManager->getAccessToken())) {
            return null;
        }
        return BearerAuthCredentialsBuilder::init($this->bearerAuthManager->getAccessToken());
    }

    public function getThirdpartytokenCredentials(): ThirdpartytokenCredentials
    {
        return $this->thirdpartytokenManager;
    }

    public function getThirdpartytokenCredentialsBuilder(): ?ThirdpartytokenCredentialsBuilder
    {
        if (
            empty($this->thirdpartytokenManager->getOAuthClientId()) &&
            empty($this->thirdpartytokenManager->getOAuthClientSecret()) &&
            empty($this->thirdpartytokenManager->getOAuthRedirectUri())
        ) {
            return null;
        }
        return ThirdpartytokenCredentialsBuilder::init(
            $this->thirdpartytokenManager->getOAuthClientId(),
            $this->thirdpartytokenManager->getOAuthClientSecret(),
            $this->thirdpartytokenManager->getOAuthRedirectUri()
        )
            ->oAuthToken($this->thirdpartytokenManager->getOAuthToken())
            ->oAuthScopes($this->thirdpartytokenManager->getOAuthScopes());
    }

    public function getLoggingConfigurationBuilder(): ?LoggingConfigurationBuilder
    {
        if (is_null($this->loggingConfigurationBuilder)) {
            return null;
        }
        $config = $this->loggingConfigurationBuilder->getConfiguration();
        return LoggingConfigurationBuilder::init()
            ->level($config['level'])
            ->logger($config['logger'])
            ->maskSensitiveHeaders($config['maskSensitiveHeaders'])
            ->requestConfiguration(RequestLoggingConfigurationBuilder::init()
                ->includeQueryInPath($config['requestConfiguration']['includeQueryInPath'])
                ->body($config['requestConfiguration']['body'])
                ->headers($config['requestConfiguration']['headers'])
                ->includeHeaders(...$config['requestConfiguration']['includeHeaders'])
                ->excludeHeaders(...$config['requestConfiguration']['excludeHeaders'])
                ->unmaskHeaders(...$config['requestConfiguration']['unmaskHeaders']))
            ->responseConfiguration(ResponseLoggingConfigurationBuilder::init()
                ->body($config['responseConfiguration']['body'])
                ->headers($config['responseConfiguration']['headers'])
                ->includeHeaders(...$config['responseConfiguration']['includeHeaders'])
                ->excludeHeaders(...$config['responseConfiguration']['excludeHeaders'])
                ->unmaskHeaders(...$config['responseConfiguration']['unmaskHeaders']));
    }

    /**
     * Get the proxy configuration builder
     */
    public function getProxyConfigurationBuilder(): ProxyConfigurationBuilder
    {
        return ProxyConfigurationBuilder::init($this->proxyConfiguration['address'])
            ->port($this->proxyConfiguration['port'])
            ->tunnel($this->proxyConfiguration['tunnel'])
            ->auth($this->proxyConfiguration['auth']['user'], $this->proxyConfiguration['auth']['pass'])
            ->authMethod($this->proxyConfiguration['auth']['method']);
    }

    /**
     * Get the client configuration as an associative array
     *
     * @see TeslaFleetManagementApiClientBuilder::getConfiguration()
     */
    public function getConfiguration(): array
    {
        return $this->toBuilder()->getConfiguration();
    }

    /**
     * Clone this client and override given configuration options
     *
     * @see TeslaFleetManagementApiClientBuilder::build()
     */
    public function withConfiguration(array $config): self
    {
        return new self(array_merge($this->config, $config));
    }

    /**
     * Validate required configuration variables
     */
    private function validateConfig(): void
    {
        $builder = TeslaFleetManagementApiClientBuilder::init();

        $thirdpartytoken = $this->getThirdpartytokenCredentialsBuilder();
        if ($thirdpartytoken != null) {
            $builder->thirdpartytokenCredentials($thirdpartytoken);
        }
    }

    /**
     * Get the base uri for a given server in the current environment.
     *
     * @param string $server Server name
     *
     * @return string Base URI
     */
    public function getBaseUri(string $server = Server::DEFAULT_): string
    {
        return $this->client->getGlobalRequest($server)->getQueryUrl();
    }

    /**
     * Returns Charging Controller
     */
    public function getChargingController(): ChargingController
    {
        if ($this->charging == null) {
            $this->charging = new ChargingController($this->client);
        }
        return $this->charging;
    }

    /**
     * Returns Energy Controller
     */
    public function getEnergyController(): EnergyController
    {
        if ($this->energy == null) {
            $this->energy = new EnergyController($this->client);
        }
        return $this->energy;
    }

    /**
     * Returns Partner Controller
     */
    public function getPartnerController(): PartnerController
    {
        if ($this->partner == null) {
            $this->partner = new PartnerController($this->client);
        }
        return $this->partner;
    }

    /**
     * Returns User Controller
     */
    public function getUserController(): UserController
    {
        if ($this->user == null) {
            $this->user = new UserController($this->client);
        }
        return $this->user;
    }

    /**
     * Returns Vehicles Controller
     */
    public function getVehiclesController(): VehiclesController
    {
        if ($this->vehicles == null) {
            $this->vehicles = new VehiclesController($this->client);
        }
        return $this->vehicles;
    }

    /**
     * Returns Vehicle Commands Controller
     */
    public function getVehicleCommandsController(): VehicleCommandsController
    {
        if ($this->vehicleCommands == null) {
            $this->vehicleCommands = new VehicleCommandsController($this->client);
        }
        return $this->vehicleCommands;
    }

    /**
     * Returns O Auth Authorization Controller
     */
    public function getOAuthAuthorizationController(): OAuthAuthorizationController
    {
        if ($this->oAuthAuthorization == null) {
            $this->oAuthAuthorization = new OAuthAuthorizationController($this->client);
        }
        return $this->oAuthAuthorization;
    }

    /**
     * A map of all base urls used in different environments and servers
     *
     * @var array
     */
    private const ENVIRONMENT_MAP = [
        Environment::PRODUCTION => [
            Server::DEFAULT_ => 'https://fleet-api.prd.na.vn.cloud.tesla.com',
            Server::AUTH_SERVER => 'https://auth.tesla.com/oauth2/v3'
        ]
    ];
}
